# go intro
## 0. go의 시작
* 구글이 2012년에 정식 버전을 발표한 프로그래밍 언어  
* 처음 목적은 c++ 대용 -> 컴파일러 언어  
    소스코드를 수정하면 자동으로 반영되지 않으므로 반드시 다시 컴파일하고 빌드해서 실행  
* 플랫폼 종속적 : 하나의 운영체제에서 빌드한 바이너리 코드는 다른 운영체제에서 사용할 수 있음  
* 문법이 간결해서 학습이 쉽다.  
* 현재 클라우드 환경에서 가장 많이 사용되는 Docker와 Kubernetes가 Go로 개발됨  
    클라우드 환경에서 동작하는 서버 애플리케이션 제작에 많이 사용 - Web Application 구축(Back End)  
## 1. 컴파일 및 실행
컴파일 및 빌ㄹ드 : go build 파일경로  
실행 : MS Windows는 실행 파일 경로를 적으면 되는데 현재 디렉토리 안에 있을 때는 파일명만 입력하면 되고, Mac이나 Linux는 현재 디렉토리에 존재하는 경우 ./파일명  

## 2. 출력  
fmt 패키지의 Print, Println, Printf 함수 이용  

## 3. 작성 방법  
* 한줄에 하나의 명령어를 입력하는 것이 기본인데, 한줄에 2개 이상의 명령어(실행문)를 입력하는 경우에는 ;로 구분  
* 주석은 //로 한줄 주석을 표현하고 /**/로 여러 줄 주석을 표현  
* 블럭을 만들 때 {는 반드시 블럭을 만드는 명령어와 동일한 줄에 선언되어야 합니다.  

# 구성요소
## 1. 프로젝트 생성  
* 워크스페이스로 사용할 디렉토리를 설정  
* 워크스페이스로 사용할 디렉토리 경로를 GOPATH라는 환경변수로 설정  
* 워크스페이스안에 src(소스파일 저장), pkg(패키지 저장), bin(바이너리 파일 저장)이라는 디렉토리를 생성  
## 2. 소스 파일 작성  
* 모든 go 파일은 패키지(소스코드의 모임)안에 소속이 되어야합니다.  
* 확장자는 go  
* 가장 상단에 자신의 패키지 이름 작성  
* 다른 패키지를 가져와서 사용할 때는 import를 해야합니다.  
* entry point는 main함수  

## 3. 데이터의 분류  
### 1) immutable과 mutable  
* immutable은 변경할 수 없는 데이터  
* mutable은 변경 가능한 데이터 - 멀티스레드를 사용하거나 지연적용을 이용한다면 동기화 문제를 고려  
* +) SQL 분류  
DDL - Create, Alter, Drop, Truncate, Rename  
DML - Select, Insert, Delete, Update  
    DML - Insert, Delete, Update + TCL - Commit, Rollback, SavePoint  
    DQL - Select  

DCL - Commit, Rollback, Savepoint, Grant, Revoke  
    DCL - Grant, Revoke  
* +) 트랜잭션
    논리적인 작업의 단위  
    한꺼번에 Commit되거나 Rollback돠어야 하는 작업  
    금융거래에서 일ㄹ반적인 트랜잭션 단위로 Commit 하거나 Rollback하는 것은 굉장히 번거로운 작업이 될 수 있음  
    원본 데이터베이스 <-> 원본 데이터베이스의 복제본 <-> 애플리케이션  
    복제본에서 원본 데이터베이스에 변경내용을 적용하는 것이 commit인데 이 작업을 수행하게 되면 우너본 데이터베이스에 lock이 설정됩니다.  
    트랜잭션으 모아서 commit하게 하도록 작성하는 것이 일반적 이비낟.  
    이렇게 만들면 우너본 데이터베이스와 복사본의 불일치가 올 수 있습니다.  


### 2) scala와 vector  
* scala는 1개의 데이터 - 리턴을 해줄 때는 없거나 1개의 데이터를 리턴해주어야합니다.  
* vector 데이터는 0개 이상의 데이터 모임 - 일반적으로 ㅁ\반복문을 이용해서 데이터를 사용하기 때문에 리턴을 해줄 때 null을 리턴하면 안됩니다.  
### 3) value와 reference - C++와 Go에서만 구분  
* 메모리에 데이터 값을 저장하는 것이 value Type  
* 메모리에 데이터가 있는 곳의 참조를 저장하는것이 Reference Type  
* 일반적으로 변수는 하나의 데이터만 저장이 가능  
    하나의 변수를 가지고 시작 지점의 위치를 기억하고 인덱스나 이름을 이용해서 다른 데이터를 찾아가는 방식을 사용  
    대부분의 Reference Type은 특별한 경우가 아니면 1개 이상의 데이터를 저장할 목적으로 사용하게 됩니다.  

    컴퓨터 프로그램은 실행이 되면 메모리를 할당받아서 프로그램을 수행하는데 이때 메모리를 2개로 구분을 합니다.  
    함수가 호출될 때 임시로 사용하는 stack이라는 공간이고 이 공간에 주로 값을 저장해서 사용합니다.  
    이 stack은 크기가 1MB로 한정되어 있습니다.  
    이 경우 1MB 이상을 사용하고자 하면 heap이라고 하는 공간을 할당 받아서 사용해야 합니다.  
    heap은 반영구적으로 사용할 수 있는 메모리 공간이고 일반적으로 시스템이 하락하는 한 무제한입니다.  

### 4) Variable과 Constant 그리고 Literal  
* Literal은 사용자가 직접 입력한 데이터  
    10, 'a', 10.3, "Hello World" 등  

* Constant는 변경할 수 없는 데이터에 붙이니 이름 - 읽기 전용을 생성하고자 할 때 사용  
* Variable은 변경할 수 있는 데이터에 붙인 이름  
* Attribute나 Property 또는 Field라고 부를 때는 대부분 변수나 상수인데 독자적으로 존재하지 못하고 다른 요소의 일부분일 떄 입니다.  
```go
class T{
    int x;
    int y;
}  
T obj = new T();
obj.x = 10;
obj.y = 20;
```  
-> T클래스의 x,y를 go에서는 field, 자바같은 객체지향언어에서는 Attribute나 Property  

## 4. 변수 선언  
* go(c++, java, kotlin, swift)는 정적 타입 언어 : 데이터의 자료형은 처음에 결정하면 변경하지 못함  
* javascript나 python은 동적 타입 언어 : 데이터으 자료형을 중간에 변경하는 것이 가능  
* go는 변수를 만들 때 자료형을 명시해서 결정할 수 있고, 데이터를 바로 대입해서 추론할 수도 있습니다.  

### 1) 선언과 초기활르 분리  
var 변수이름 자료형  
변수이름 = 데이터  

### 2) 선언과 초기화를 동시에 수행  
var 변수이름 자료형 = 초기값  
var 변수이름 = 초기값 // 자료형 추론  

* 함수 내에서 만들어지는 지역 변수의 경우는 var를 생략하는 것이 가능  
변수이름 := 초기값  

* 동일한 자료형의 변수는 한 줄에 선언 가능  
```go
var 변수이름1, 변수이름2, ... , 자료형  

//국어점수 영어점수 수학점수를 저장하는 변수를 생성  
var kor, eng, math, int

//이름과 주소를 저장하는 변수를 생성  
var 변수이름1, 변수이름2, ... 자료형  
```  

* 자료형이 다른 여러개의 변수를 한꺼번에 초기화하는 것이 가능 - 알고리즘 문제 풀 때 라인수를 많이 줄여줌  

정수로 된 점수와 문자열로 된 이름과 실수로 된 키를 저장  
var score = 0
var name = "adam"
var height = 0.0

var score, name, height = 0, "adam", 0.0  

일반적으로 알고리즘 문제 해결에 많이 사용하는 언어 중에서 라인 수를 비교해보면 C++ > Java > Python > Go  

## 5. 기본 자료형  
* bool : true 또는 false를 저장  
* 부호있는 정수 : int, int8, int16, int32, int64 - int는 시스템에 따라 다름(32비트나 64비트)  
* 부호없는 정수 : unit, uint8, uint16, uint32, uint64, uintptr(참조를 저장하기 위한 자료형)  
* 하나의 바이트 또는 ASCII 문자 : byte  
* 하나의 유니코드 문자 : rune  
* 실수 : float32, float64  
* 복소수 : complex64, complex128  
* 문자열 : string -> byte의 collectiono으로 간주  

### 1) 정수 저장
* 컴퓨터는 2진수로 저장  
* 부호있는 정수의 경우는 첫번째 비트를 부호로 간주하고 양수는 첫번째 비트를 0으로 하고 나머지 비트에 저장하며 양수는 2의 보수로 저장  
```go
var x int8 = 11
```  
int8이므로 8개의 비트를 할당 
00000000
11 -> 1011(2)
실질적으로 x에는 00001011이라는 이진수를 저장  

x=-11이면 11110101(2)  
* 11의 2의 보수 구하기
    2의 보스는 1의 보수 +1을 하거나 맨 오른쪽 맨 뒤에서 첫번째 1을 만날 때까지는 그대로 두고 그 앞의 부분들만 0은 1로 1은 0으로 변경하면 됩니다.  
    1의 보수는 0은 1ㄹ로 1은 0으로 변경하면 됩니다.  

* 00001011의 1의 보수
11110100이고, +1하게 되면 11110101인데, 이는 11의 2의 보수입니다.  
11110101이 -11인 것! 

* x = 128  
128은 2진수로 변경하면 10000000
x는 int8입니다.  
첫 번째 비트는 양수인 경우 0으로 만들어야 하고, 수정하면 안됩니다. 8번째 자리가 1이므로 이 데이터는 int8에 저장할 수 없습니다. 이렇게 숫자의 범위가 저장할 수 있는 범위를 양수 쪽으로 넘어선 경우를 overflow라고 합니다.  음수 쪽으로 넘어간 경우는 underflow. 8비트를 가지면 2의 8승으로 256가지 모형을 나타냅니다. 256가지 모형을 양수와 음수로 분리하면 128가지가 가능한데, 양수는 0부터 시작하므로 0~127까지 표현을 할 수 있고, 음수는 -1부터 시작하기때문에 -1~-128까지 됩니다.  

8비트를 가지면 2의 8승으로 256가지 모형을 나타냅니다.  256가지 모형을 양수와 음수로 분리하면 각각 128가지 모형을 나타냅니다.  

* -1을 8비트로 저장  
    1의 2의 보수를 저장해야 하므로 00000001 -> +1, 11111111 -> -1(모든 비트가 전부 1)  

* uint
    uint는 양수만 저장하는 자료형을 모든 비트를 사용합니다.  
    uint8은 256가지를 표현할 수 있으므로 0부터 255까지 저장할 수 있습니다.  
    255는 이진수로 변

* 자바에서 unsigned
    자바에서는 unsigned자료형이 없지만 -1을 사용하는 경우가 있다. 
    -1은 큰 수를 의미하고, 위치에는 음수가 없으므로 String클래스의 indexOf의 끝값이 -1이 리턴이 됩니다.  
    처음부터 끝까지 문자열을 가져온다거나 할 때 사용한다.
    
### 2) 실수를 저장  
* 부호 와 지수 와 가수를 나누어서 저장  
12.7  
* *0 0.127E+002  
* 각각의 숫자는 2진수로 변환해서 저장  
* 소수를 2진수로 변경할 때는 소수 부분에 2를 곱해서 나온 정수 부분을 순서대로 기재하면 됩니다.  

0.75라는 숫자를 2진수로 변환: 0.11(2)  

0.75 * 2 => 1.5   
0.5 * 2 => 1.0  
0.0  

* 0.6을 2진수로 변환: 0.1001100110011001...   
0.6 * 2 = 1.2  
0.2 * 2 = 0.4  
0.4 * 2 = 0.8  
0.8 * 2 = 1.6  
0.6  

### 3)ascii 문자(영문이나 숫자)  
* byte로 저장하고 ' ' 안에 하나의 문자를 표현  

### 4)unicode 문자  
* rune 이라는 자료형으로 저장하는데 " "안에 하나의 문자를 기재하거나 \u코드값을 설정하면 됩니다.  
* 코드값은 16진수로 표현합니다.  
* 하나의 unicode는 3바이트 입니다.  
  
### 5)기본값  
* 초기화를 하지 않은 변수에는 기본값이 설정됨  
* 숫자는 0, bool 은 false, string은 "", 포인터는 nill(NULL)  

### 6) 문자열  
* " " 안에 유니코드 나 문자를 나열해서 표현  
* 여러 줄로 구성된 문자열을 만들고자 할 때는 ``(backtick, back quote)를 이용  
* 문자열의 바이트 크기는 len 함수를 이용해서 구할 수 있음  
* 글자수는 unicode 의 utf8 패키지의 RuneCountlnString 함수를 이용  
* 문자열[인덱스]를 이용해서 문자 단위로 접근 가능  
* +연산자를 이용해서 결합 가능  
* 동일성 여부는 ==  
* 제어문자 사용 가능  
    \n: 줄 바꿈
    \t: 탭
    \r: 커서를 맨 앞으로 이동
    줄 바꿈을 하고 커서를 맨 앞으로 옮길 때 \r\n으로 작성하는 경우가 있습니다.  

### 7) 자료형 변환  
(변경하고자 하는 자료형)데이터  

## 6. 연산자  
### 1) = 대입 연산자  
오른쪽의 데이터가 참조하는 영역을 왼쪽의 변수에 대입  

### 2) :=
선언과 대입을 동시에 수행  

### 3) 증감연산자  
++, -- 
### 4) 사칙연산자  
%, *, /, +  

### 5) shift  
* <<는 1번 이동할 때마다 곱하기 2한 효과  
* >>는 1번 이동할 때마다 나누기 2한 효과  

### 6) 비트 논리 연산자  
* 비트 단위로 연산해서 결과를 정수로 리턴  
* &(and)
    둘다 1일때만 1  
    0과 and를 하면 결과는 무조건 0 - 삭제를 할 때 주로 이용
* |(or)
    둘다 0일때만 0  
    0과 or을 하면 결과는 그대로 리턴 - 데이터를 복사할 때 사용  
    이미지에서 2개의 색상을 더하는 경우도 or  
* ^(xor)
    2개가 같으면 0 다르면 1  
* &^(and not)

* ex) 
    20 -> 00000000 00010100  
    17 -> 00000000 00010001  
    20 & 17 -> 00000000 00010000  
    20 | 17 -> 00000000 00010101  
    20 ^ 17 -> 00000000 00000101  

### 7) 연산 후 할당  
+=, -= 등  

### 8) 비교 연산자  
=>, ==, != <, <=, >, >=  

### 9) 논리 연산자 : &&, ||, !  
* && : 2개의 표현식 모두 true일 때 true, 나머지 경우는 false  
    앞의 표현식의 결과가 false라면 뒤의 표현식은 확인하지 않습니다.  
* || : 2개의 표현식 모두 false일 때 false, 나머지 경우는 true  
    앞의 표현식의 결과가 true라면 뒤의 표현식은 확인하지 않습니다.  

### 10) 참조 연산 : &  
* &다음에 변수를 설정하면 변수가 가리키고 있는 참조를 의미합니다.  

### 11) 역참조 연산 : *  
참조를 저장하고 있는 데이터에서 참조하고 있는 곳의 실제 값을 가져올 때 사용하는 연산자  

### 12) 채널 수신 연산 : <-  

## 7. Constant(상수)  
* 변하지 않는 읽기 전용의 데이터  
* var 대신에 const를 사용해서 선언  
* 반드시 초기화를 해서 생성  
* 여러 개의 상수를 동시에 생성하는 것이 가능  
* enum(나열형 상수)  
    여러개의 상수를 하나의 묶음으로 만드는 거  
    iota를 이요하면 0부터 싲가하는 정수르 할당하는 것이 가능  
    iota는 sequence의 기능을 가짐  

```go
func main() {
	const (
		MIN    = 0
		NORMAL = 5
		MAX    = 10
	)
	Println(MAX)

	const (
		ZERO = iota
		ONE
		TWO
	)
	Println(TWO)

	const (
		LBUTTON = 1 << iota
		RBUTTON = 1 << iota
		SHIFT   = 1 << iota
		CONTROL = 1 << iota
	)
	Println(CONTROL)

	const (
		SALES    = iota * 10
		ACCOUNT  = iota * 10
		RESEARCH = iota * 10
	)
	Println(RESEARCH)
}
```  

### 8. 포인터
* 메모리의 참조를 나타내기 위한 자료형  
* 포인터 변수를 선언  
```go
var 이름 * 가리키는 공간의 자료형  
```  

* 참조를 대입  
```go
이름 = 메모리 참조(다른 포이터 변수나 &일반변수)  
```  

* 참조하고 있는 공간의 데이터 접근  
    *이름  

## 9. 제어문  
### 1) if
* 단순 if  
```go
if 표현식 {
    // 수행할 내용 
}
```  

* if ~ else
```go
if 표현식 {
    // 수행할 내용 
} else {
    // 수행할 내용
}
```  

* if ~ else if .. ~ else(생략 가능)  
```go
if 표현식 {
    // 수행할 내용 
} else if 표현식 {
    // 수행할 내용
} else{
    // 수행할 내용
}
```  

### 2) switch  
```go
switch 변수{
    case 값1 :
        표현식1
    case 값2 :
        표현식2
    ...
    default
        표현식
}
```  
-> 변수와 일치하는 case 구문의 표현식을 수행하고 종료  
    일치하는 값이 없으면 default 구문을 수행  
    변수에 문자열, 조건문 가능  

-> 기본적으로 fallthrough를 하지 않음  
    아래쪽 구문을 수행하고자 하는 경우 fallthrough를 설정해야 합니다.  

### 3) for
```go
for 초기식; 표현식; 변화식 {
    // 수행할 내용
}
```  
* 초기식은 맨 처음 1번만 수행
* 표현식은 true이면 내용을 수행하고 변화식으로 이동  
* 변화식의 내용을 수행하고 표현식을 확인  
* 표현식을 제외한 부분을 생략하는 것이 가능 - while  

### 4) 제어문 안에 제어문 사용 가능  
* if나 switch안에 for를 넣을 수도 있고, for안에 if나 switch를 삽입할 수 있음  

### 5) break
* for나 switch안에 사용되서 for나 switch를 종료하는 역할  

### 6) continue  
* for안에 사용이 되서 변화식으로 바로 이동하는 역할  

### 7) 레이블 사용  
* 반복문이 중첩되는 경우 레이블 사용이 가능  
    레이블을 이용해서 특정 반복문을 중단하건 다음으로 진행하는 것이 가능  

### 8) go to  
* go to 레이블이름을 이용하면 레이블 이름에 해당하는 곳을 제어권이 이동합니다.  
    레이블은 하단에 존재해서 넘어가는 역할을 수행합니다.  
* 구조적 프로그래밍에서는 goto사용을 권장하지 않습니다.  
    Java같은 경우는 goto는 const와 더불어 예약어이지만 사용할 수 없습니다.  
    위의 내용을 반복문 1번만 사용해서 작성
출력하는 구문은 다른 구문을 사용할 수 없습니다.
반복문의 개수를 줄이는 것은 중요한 문제
### 9) 연습  
```go
package main

import "fmt"

func main(){
	for i:=0; i<5; i++{
		for j:=0; j<5; j++{
			fmt.Print("*")
		}
		fmt.Print("\n")
	}
}
```  

* 위의 내용을 반복문 1번만 사용해서 작성  
    출력하는 구문은 다른 구문을 사용할 수 없습니다.  
    반복문의 개수를 줄이는 것은 중요한 문제  

* 아래처럼 변경
*  
**  
***  
****  
*****  

* 아래처럼 변경
*****  
****  
***  
**  
*  

* 아래처럼 변경
*  
**  
***  
**  
*  

* 이렇게 출력하도록 작성  
공백4개*  
공백3개***  
공백2개*****  
공백1개*******  
*********  

* var str : string = "가나다&가나다"  
글자 수 개수 출력  
첫번째 글자 와 마지막 글자의 동일성 여부를 확인  

* 2부터 1000까지 prime(소수)의 개수  
    소수는 1과 자기자신으로만 나누어 떨어지는 수  

* 2부터 1000까지 완전수의 개수 : 3개  
    완전수는 자기 자신을 제외한 약수의 합이 자기 자신인 수  
    6 -> 1,2,3,6이 약수인데 자기자신을 제외한 값의 합이 6이므로 완전수

* 10진수를 32자리 2진수로 출력  

* 선택 정렬, 버블 정렬, 삽입 정렬, 2-way merge, quick 정렬  

* 이분 검색  

## 10. function(함수)  
* 코드를 하나의 이름으로 사용하기위해서 묶어둔 것  
* 일정한 패턴을 갖는 코드가 연속적으로 존재하는 경우는 반복문을 이용해서 묶을 수 있지만 일정한 패턴을 갖는 코드가 연속적이지 않은 경우는 반복문으로 묶을 수 없음  

### 1) 함수 선언 방법  
```go
func 함수이름(매개변수 나열) 리턴타입{
    함수의 내용
    (return 데이터)
}
```  
* 매개변수는 없을 수 있지만 ()는 생략 안됨  
* 리턴타입은 return 하는 데이터가 없다면 생략 가능  
* 함수의 메모리 영역에 전역의 형태로 저장됨  

### 2) 함수 호출  
```go
함수이름(매개변수)
```  
* 전역영역에서 동일한 이름의 함수를 찾아서 전개하고, stack을 할당 받아서 함수의 내용을 수행한 후 함수의 작업이 종료되거나 return을 만나면 함수를 호출한 곳으로 돌아옵니다.  
    return 할 때는 데이터를 가지고 리턴할 수 있고 데이터없이 리턴할 수 도 있습니다.  
