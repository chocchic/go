# 프로그램의 메모리 구조  
H/W <- Driver -> OS(운영체제 - 현존하는 운영체제의 출발점을 Unix로 보는 데 Unix를 만들 때 사용했던 커널의 90%이상이 C언어로 제작) <- 바이너리 코드 -> 응용 프로그램  

H/W <- Driver -> OS(운영체제 - 현존하는 운영체제의 출발점을 Unix로 보는 데 Unix를 만들 때 사용했던 커널의 90%이상이 C언어로 제작) <- Native Code -> Virtual Machine <- 바이너리 코드 -> 응용 프로그램(Java 또는 JVM 계열 언어, C# 등의 Microsoft Windows 용 애플리케이션을 제작하기 위한 MS 언어나 프레임워크)  

* 초창기 프로그래밍에서는 레지스터(CPU 안에 있는 메모리)만을 이요해서 프로그래밍을 수행  
프로그래밍을 하기 위해서는 기계 구조를 전부 알아야하는데 기계마다 구조가 달라서 프로그래밍하기가 매우 어려움  

* 레지스터와 메인 메모리를 나누어서 프로그램을 구동  
    초창기에는 메인 메모리를 분할하지 않음  

* 레지스터를 사용하는 부분은 프로그래밍 언어에게 맡기고 메모리만을 이용해서 프로그래밍  
    하나의 메모리 영역만으로 프로그래밍을 하게 되면 메모리 관리를 전부 프로그래머가 해야 함  

    일시적으로 필요한 데이터를 저장하는 영역 - Stack이라는 자료구조 이용 - Stack의 생성은 함수 호출로 하고 소멸은 함수의 수행이 종료되면 자동 소멸, 크기에 제한이 있음 - 1 MB, Stack에서 1MB 이상의 데이터가 필욯나 경우에는 Heap에 데이터를 저장하고 Heap의 참조(메모리를 구별하기 위한 어떤 코드)를 가리키는 형태로 사용하는데 이렇게 현재 위치가 아닌 다른 위치의 데이터의 참조를 가리키기 위한 자료형을 C계열의 언어에서는 포인터라고 부릅니다.  

    반영구적으로 필요한 데이터를 저장하는 영역 - Heap - 프로그램이 실행되면 생성되고 프로그램이 종료되면 소멸, 크기 제한이 없음  
    
    이 영역을 다시 개발자가 동적으로 할당하고 정리할 수 있는 영역과 한 번 할당하면 절대 소멸시킬 수 없는 영역(함수, 클래스를 위한 코드, 리터럴 형태의 상수 등을 저장, 함수나 클래스의 이름은 외부에서 사용할 수 있도록 등록해줌)으로 구분해서 사용  
    이 영역을 정리하는 방법은 개발자가 직접 정리하는 방식(C, C++)과 누군가가 대신 정리해주는 방식(Garbage Collection - 가리키는 데이터가 없을 때 정리하는 방식과 reference count를 이용해서 정리하는 방식)으로 나눕니다.  
    자바는 Pointer라는 개념 대신에 Value Type처럼 사용하는 Premetive type과 NonPremetive type으로 나눕니다.  

## 1. Pointer   
* 다른 메모리 영역의 참조를 가리키기 위한 자료형  
### 1) 선언  
```go
var 변수명 * 가리키기 위한 메모리 영역의 자료형  
```  
* 포인터의 자료형은 무조건 부호없는 정수이고 크기는 시스템의 파일 시스템에 따라 정해집니다.  

* 변수를 선언하게 되면 다른 영역의 참조를 저장할 준비만 된 것  
    이러한 상태를 nil(다른 언어의 null과 유사, null은 ASCII Code로 0)이라고 합니다.  

### 2) 메모리 할당  
* 포인터 변수가 사용할 수 있는 공간을 생성  
new (사용할 메모리 영역의 자료형)

* 기본값으로 전부 초기화  

### 3) 메모리 영역을 직접 가리키기  
* 일반 데이터의 경우는 & 변수명  
* 포인터 변수의 경우는 포인터 변수명  

### 4) 사용  
* 포인터 변수는 메모리의 참조를 저장하고 있음  
* 포인터 변수를 이용해서 가리키는 영역에 저장된데이터를 사용하고자 할 때는 앞에 *을 붙이면 됩니다. 
    역참조라고도 함  
* 포인터 변수가 다른 포인터 변수의 메모리 영역을 기리킬 수 있습니다.  
    이를 다중 포인터라고 하는데 네트워크 프로그래밍에서 사용하는 경우가 있습니다.  

### 5) call by value와 call by reference  
* call by value는 함수의 매개변수가 value type으로 함수 내에서 매개변수로 받은 데이터를 변경해도 매개변수로 넘겨준 데이터에는 아무런 영향이 없는 것  

* call by reference는 함수의 매개변수가 reference type(pointer)로 함수 내에서 매개변수로 받은 데이터를 변경하면 매개변수로 넘겨준 데이터가 변경되는 것  

* 구조적 프로그래밍에서는 call by reference를 이용하는 것보다는 리턴을 해서 새로운 데이터를 넘겨주는 것을 권장  

## 2. struct(구조체)  
* 여러 데이터의 집합  

### 1) 선언
```go
type 구조체이름 struct{
    필드이름 자료형
}
```  
필드 이름을 만들 때 주의할 점은 필드 이름이 소문자로 시작하면 다른 패키지에서 사용할 수 없습니다.
public이나 private이 없음  

### 2) 초기화  
* 전체 필드 초기화
```go
구조체이름 {
    필드이름:데이터,
}
```  

* 필드 각각을 초기화하거나 사용  
```go
var 변수명 = 구조체이름{}
변수명.필드이름 = 데이터
```  

### 3) 구조체 포인터  
* 초기화
```go
&구조체이름{
    필드이름:데이터,
}
```  

* 필드 각각을 초기화하거나 사용  
```go
var 변수명 = &구조체이름{}
변수명.필드이름 = 데이터
```  

* 동적 메모리 할당  
```go
var 변수명 = new(구조체이름)
변수명.필드이름 = 데이터
```  

* 구조체에는 클래스와 다르게 생성자를 만들 수 없음  
    생성자와 유사한 형태로 함수를 이용해서 구조체를 생성할 수는 있습니다. 동적 메모리 할당을 받아서 리턴하는 형태로 함수를 만듭니다.  

* +)
    값을 대입하는 것은 복사가 이루어지는 것, 참조를 대입하는 것은 복사 없이 참조만 전달하는 것입니다.  
    동적 메모리 할당은 heap에 할당하는 것입니다.  
    new는 동적으로 heap에 생성  
    동적 메모리 할당이 아니면 기본적으로 stack에 생성  
    heap을 사용하게 되면 메모리 사용량은 거의 무한대이고, 원하는 시점에 할당하고 원하는 시점에 정리하는 것이 가능해짐  

### 4) 메서드  
* 함수는 전역 공간에 존재해서 아무 곳에서나 이름만으로 호출할 수 있는 것을 의미하고 메서드는 리시버를 통해서 호출하는 함수를 의미합니다.  
* 구조체 안에 직접 함수를 만들 수는 없습니다.  
* 다른 종류의 타입과 연결해서 타입으로 만들어진 데이터를 통해서 함수를 호출할 수 있습니다.  
    ```go
    func(리시버이름 * 구조체이름) 함수이름(매개변수)리턴타입{
        // 함수 내용
    }
    ```  

* 메서드 호출은 구조체변수.함수이름(매개변수)의 형태입니다.  
    호출하는 구조체 변수의 참조가 리시버 이름에 대입됩니다.  

* 메서드를 생성할 때 리시버 다음에 *을 생략하면 구조체가 복제되서 대입이 됩니다.  
    메서드 안에서 원본 구조체의 데이터를 사용할 수 없습니다.  

* 메서드 안에서 리시버가 사용이 안될때는 리시버 이름대신에 _를 사용할 수 있습니다.  

## 3. 구조체 사이의 관계  
### 1) has a  
* 하나의 구조체 선언 안에 다른 구조체가 필드로 존재하는 경우  

### 2) is a 상속  
* 구조체 안에 다른 구조체 이름을 필드이름 없이 이름만 기재
* 사용하는 이유 : 기능확장 - 유지 보수가 편리  
* ex) A class를 이용해서 프로그램 작성  
    A class에 기능 확장 - A class를 수정, 이전에 만든 프로그램을 사용하는 예기치 않은 문제가 발생할 가능성이 있음 -> A class는 그대로 두고 A를 상속받은 A의 하위 클래스를 만들어서 확장    

## 4. interface  
* 메서드의 모양만 가지고 있는 개체  
* 인터페이스는 변수를 만들어도 메모리 공간을 할당받지 않습니다.  

### 1) 생성  
```go
type 인터페이스이름 interface{
    // 함수 선언
}
```  

### 2) 인터페이스 적용  
* 인터페이스에 속한 함수를 메서드로 소유한 객체를 인터페이스 변수에 대입해서 사용  