# 프로그램의 메모리 구조  
H/W <- Driver -> OS(운영체제 - 현존하는 운영체제의 출발점을 Unix로 보는 데 Unix를 만들 때 사용했던 커널의 90%이상이 C언어로 제작) <- 바이너리 코드 -> 응용 프로그램  

H/W <- Driver -> OS(운영체제 - 현존하는 운영체제의 출발점을 Unix로 보는 데 Unix를 만들 때 사용했던 커널의 90%이상이 C언어로 제작) <- Native Code -> Virtual Machine <- 바이너리 코드 -> 응용 프로그램(Java 또는 JVM 계열 언어, C# 등의 Microsoft Windows 용 애플리케이션을 제작하기 위한 MS 언어나 프레임워크)  

* 초창기 프로그래밍에서는 레지스터(CPU 안에 있는 메모리)만을 이요해서 프로그래밍을 수행  
프로그래밍을 하기 위해서는 기계 구조를 전부 알아야하는데 기계마다 구조가 달라서 프로그래밍하기가 매우 어려움  

* 레지스터와 메인 메모리를 나누어서 프로그램을 구동  
    초창기에는 메인 메모리를 분할하지 않음  

* 레지스터를 사용하는 부분은 프로그래밍 언어에게 맡기고 메모리만을 이용해서 프로그래밍  
    하나의 메모리 영역만으로 프로그래밍을 하게 되면 메모리 관리를 전부 프로그래머가 해야 함  

    일시적으로 필요한 데이터를 저장하는 영역 - Stack이라는 자료구조 이용 - Stack의 생성은 함수 호출로 하고 소멸은 함수의 수행이 종료되면 자동 소멸, 크기에 제한이 있음 - 1 MB, Stack에서 1MB 이상의 데이터가 필욯나 경우에는 Heap에 데이터를 저장하고 Heap의 참조(메모리를 구별하기 위한 어떤 코드)를 가리키는 형태로 사용하는데 이렇게 현재 위치가 아닌 다른 위치의 데이터의 참조를 가리키기 위한 자료형을 C계열의 언어에서는 포인터라고 부릅니다.  

    반영구적으로 필요한 데이터를 저장하는 영역 - Heap - 프로그램이 실행되면 생성되고 프로그램이 종료되면 소멸, 크기 제한이 없음  
    
    이 영역을 다시 개발자가 동적으로 할당하고 정리할 수 있는 영역과 한 번 할당하면 절대 소멸시킬 수 없는 영역(함수, 클래스를 위한 코드, 리터럴 형태의 상수 등을 저장, 함수나 클래스의 이름은 외부에서 사용할 수 있도록 등록해줌)으로 구분해서 사용  
    이 영역을 정리하는 방법은 개발자가 직접 정리하는 방식(C, C++)과 누군가가 대신 정리해주는 방식(Garbage Collection - 가리키는 데이터가 없을 때 정리하는 방식과 reference count를 이용해서 정리하는 방식)으로 나눕니다.  
    자바는 Pointer라는 개념 대신에 Value Type처럼 사용하는 Premetive type과 NonPremetive type으로 나눕니다.  

## 1. Pointer   
* 다른 메모리 영역의 참조를 가리키기 위한 자료형  
### 1) 선언  
```go
var 변수명 * 가리키기 위한 메모리 영역의 자료형  
```  
* 포인터의 자료형은 무조건 부호없는 정수이고 크기는 시스템의 파일 시스템에 따라 정해집니다.  

* 변수를 선언하게 되면 다른 영역의 참조를 저장할 준비만 된 것  
    이러한 상태를 nil(다른 언어의 null과 유사, null은 ASCII Code로 0)이라고 합니다.  

### 2) 메모리 할당  
* 포인터 변수가 사용할 수 있는 공간을 생성  
new (사용할 메모리 영역의 자료형)

* 기본값으로 전부 초기화  

### 3) 메모리 영역을 직접 가리키기  
* 일반 데이터의 경우는 & 변수명  
* 포인터 변수의 경우는 포인터 변수명  

### 4) 사용  
* 포인터 변수는 메모리의 참조를 저장하고 있음  
* 포인터 변수를 이용해서 가리키는 영역에 저장된데이터를 사용하고자 할 때는 앞에 *을 붙이면 됩니다. 
    역참조라고도 함  
* 포인터 변수가 다른 포인터 변수의 메모리 영역을 기리킬 수 있습니다.  
    이를 다중 포인터라고 하는데 네트워크 프로그래밍에서 사용하는 경우가 있습니다.  

### 5) call by value와 call by reference  
* call by value는 함수의 매개변수가 value type으로 함수 내에서 매개변수로 받은 데이터를 변경해도 매개변수로 넘겨준 데이터에는 아무런 영향이 없는 것  

* call by reference는 함수의 매개변수가 reference type(pointer)로 함수 내에서 매개변수로 받은 데이터를 변경하면 매개변수로 넘겨준 데이터가 변경되는 것  

* 구조적 프로그래밍에서는 call by reference를 이용하는 것보다는 리턴을 해서 새로운 데이터를 넘겨주는 것을 권장  

## 2. struct(구조체)  
* 여러 데이터의 집합  

### 1) 선언
```go
type 구조체이름 struct{
    필드이름 자료형
}
```  
필드 이름을 만들 때 주의할 점은 필드 이름이 소문자로 시작하면 다른 패키지에서 사용할 수 없습니다.
public이나 private이 없음  

### 2) 초기화  
* 전체 필드 초기화
```go
구조체이름 {
    필드이름:데이터,
}
```  

* 필드 각각을 초기화하거나 사용  
```go
var 변수명 = 구조체이름{}
변수명.필드이름 = 데이터
```  

### 3) 구조체 포인터  
* 초기화
```go
&구조체이름{
    필드이름:데이터,
}
```  

* 필드 각각을 초기화하거나 사용  
```go
var 변수명 = &구조체이름{}
변수명.필드이름 = 데이터
```  

* 동적 메모리 할당  
```go
var 변수명 = new(구조체이름)

```  
