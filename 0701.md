# 동시성(Concurrency)  
* 이 섹션으 ㅣ내용은 웹 서버 프로그래밍만 하는 경우 사용하지 않을 수도 있습니다.
    애플리케이션 개발에 있어서 필수적인 요소이기 때문에 중요한 개념입니다.  
    웹 프레임워크를 사용하는 경우 대부분 프레임 워크가 간편한 형태로 사용할 수 있도록 만들어서 제공합니다.  
* +) java - 스레드, GUI Programming, Network Programming, JDBC  
    Spring Framework를 사용하면 Http요청은 알아서 스레드로 만들어서 처리를 해줍니다.  
    최근에는 PC용 어플리케이션보다는 웹 브라우저용 또는 스마트폰 애플리케이션을 많이 사용  

## 1. 동시성  
* 프로그램을 여러 독립된 작은 단위로 나누고 주어진 자원을 사용해서 빠르게 동시 다발적으로 수행하는 행위  
* 보통은 스레드와 동일시하지만 스레드보다는 조금 더 포괄적인 개념  

### 1) Thread  
* 프로그램을 병렬로 수행할 수 있도록 OS에서 지원하는 기능  
    실행 중간에 다른 Thread로 제어권 이동이 가능하다는 것이 프로세스와 다른 점  

* 프로그램읭 일부분을 할당받아서 처리하는데 일반적으로 하나의 함수  

### 2) Go의 동시성  
* 프로그램을 여러 개의 독립된 작업으로 나누고(함수) 이를 스레드에 할당해서 수행하는데 스레드의 개념에서는 하나의 함수만 실행하지만 동시성의 개념에서는 하나의 스레드가 여러 개의 함수를 실행할 수 있도록 합니다.  

## 2. GoRoutine  
* 경량 스레드  
* 모든 Go의 함수는 GoRoutine입니다.  
* 함수를 GoRoutine으로 실행하고자 할 때는 함수를 호출할 때 앞에 go를 붙여주면 됩니다.  

* +) CPU  
    - 레지스터 : 임시기억장치  
    - 제어장치(Control Unit)  
    - 연산장치(Arithmetic Logic Unit) : 코어라고 부름  
    - Cache Memory : Main Memory에서 자주 사용하는 데이터를 저장하기 위한 임시기억장치  

* +) Context Switching(문맥 교환)  
    작업을 컴퓨터에서 수행해달라고 요청을 하면 컴퓨터는 PCB(Process Control Block - 작업에 대한 정보를 저장한 자료구조)를 생성해서 작업을 수행합니다.  
    작업 중간에 다른 작업으로 제어권을 옮기면 PCB에 현재까지의 작업 내역을 저장하고 


## 3. Channel  
### 1) 데이터 공유  
* 여러개의 작업이 동시에 수행되는 경우 고려할 점 중의 하나가 데이터를 어떻게 같이 사용하냐는 문제  
* 공유 메모리를 사용하는 방식과 채널을 이용하는 방식(데이터전달)이 있습니다.  
* 스레드에서는 공유 메모리를 이용하는 방식을 이용하고 Lock의 개념을 사용  
* 채널을 이용하는 방식은 통신의 개념을 가지고 공유데이터를 수행하는 형태인데 데이터를 사용해야 하는 쪽에서는 데이터를 보내주는 쪽이 데이터를 전송해줄 때까지 대기하고 있다가 데이터를 전송받으면 자신의 작업을 수행하는 방식으로 동작  

### 2) 일반 채널 - 동기채널  
* 생성  
```go
make(chan 데이터의 자료형)
```  

* 채널에 데이터 저장
```go
채널 <- 데이터  
```  

* 채널의 데이터를 저장  
```go
변수 := <- 채널  
```  


### 3) 버퍼 채널 - 비동기 채널  
* 여러 개의 값을 버퍼에 저장할 수 있는 채널  
* 생성
```go
make(chan 데이터의자료형, 개수)
```  

### 4) select  
* 여러 채널을 동시에 제어할 수 있는 것  
```go
select{
    case 변수이름 := <- 채널:
        // 수행할 내용
    case 변수이름 := <- 채널:
        // 수행할 내용
    case <- time.After(시간)
        // 수행할 내용
    // ...
}
```  

* +) 동시에 여러 개의 작업을 수행할 때 알아야하는 개념  
    공유 데이터 : 여러 개의 작업이 같이 사용하는 데이터  
    critical section(임계 영역) : 공유 자원을 사용하는 코드영역  

    동시에 여러 개의 작업이 수행될 때 발생할 수 있는 문제  
        - 공유 데이터 동시 수정 문제
            하나의 작업이 데이터를 수정하고 읽기 작업을 하려고 하는데 데이터를 수정한 상태에서 다른 작업이 데이터를 다시 수정하게 되면 이전 작업은 자신이 수정한 내용을 잃어버리거나 잘못된 결과를 읽어낼 수 있는 문제  

        - 생산자와 소비자 문제  
            생산자가 사용하는 자원을 소비자가 사용하는 경우 생산자가 생성하기 전에 소비자가 소비하려고 해서 발생하는 문제  
        
        - Deadlock  
            결코 발생할 수 없는 사건을 무한정 기다리는 것  

* +) 동시에 여러 개의 작업이 수행될 때 발생할 수 있는 문제 해결책  
    - 공유 데이터 동시 수정 문제 해결  
        Mutual Exclusion(상호 배제, 줄여서 Mutax) : 하나의 작업이 수정중인 자원은 작업이 완료되기 전까지 다른 작업이 수정할 수 없음  

        Lock을 이용해 해결  

    - 생산자와 소비자 문제 해결  
        wait와 signal(notification)을 이용해서 해결  
    
    - DeadLock  
        이 문제가 발생하지 않도록 회피, 발견, 회복  

## 4. Sync 패키지
### 1) 동기화 관련 객체 패키지  
* Mutex : 동시에 사용하지 못하도록 해주는 동기화 관련 객체  
* RWMutext : 읽기와 쓰기로 작업을 나누어서 동기화 해주는 객체  
* Cond : 대기중인 하나의 작업을 수행하도록 하거나 대기중인 모든 작업을 수행하도록 해주는 객체  
* Once : 한번만 실행하도록 해주는 객체  
* Pool : 동시에 사용할 수 있는 객체 풀을 만들어서 객체를 재사용하는 것  
    Spring에서 데이터베이스 연동을 할 때는 ConnectionPool을 사용합니다.  
* WaitGroup : GoRoutine이 끝날 때까지 대기  
* Atomic : 원자적 연산으로 어떤 작업이 중단되지 않고 한꺼번에 수행되도록 해주는 연산  

### 2) Mutex  
* 구조체 : sync.Mutex  
* 함수 : Lock(), UnLock()  


### 3) RWMutex : 읽기와 쓰기 작업을 나누어서 사용을 못하도록 하는 객체  
* 구조체 : sync.RWMutex  
* 함수 : Lock(), Unlock(), RLock(), RUnlock()  
    RLock()과 RUnlock()은 읽기 전용 뮤텍스  
    Lock()과 Unlock()은 쓰기전용 뮤텍스  

### 4) Cond  
* 구조체 : sync.Cond  
* func NewCond(l Locker) * Cond : 객체 생성  
* func (c * Cond) Wait() : 대기  
* func (c * Cond) Signal() : 대기하고 있는 고루틴 하나만 깨움  
* func (c * Cond) Broadcast() : 대기하고 있는 고루틴 전부 깨움  