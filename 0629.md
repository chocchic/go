## 1. Function(함수)  
* +) C++이난 Go는 2pass Compiler  
    코드를 전부 읽어서 선언부분을 확인해서 선언하는 부분들을 전부 메모리에 로드  
    실행하거나 호출하는 코드를 수행  
    선언하는 부부은 호출하는 부분 뒤에 있어도 됩니다.  

### 1) 함수의 선언위치는 함수의 호출보다 뒤여도 됨.  

### 2) 매개변수가 여러개인 경우 매개변수의 자료형이 동일하다면 1번만 기재해도 됩니다.  

### 3) 가변 인자  
```go
매개변수이름 ... 자료형  
```  
* 매개변수를 여러 개 대입해도 됩니다.  
* 매개변수를 여러개 대입하면 하나의 데이터 묶음으로 만들어서 내부에서 사용합니다.  
* 가장 마지막 매개변수로 사용되어야 합니다.  

### 4) 함수에서 여러 개의 데이터를 리턴하는 것이 가능  
* +) UML에서 메서드 표기법
    이방식으로 GO, kotlin, Swift는 함수를 정의합니다.  
```go
메서드이름(매개변수이름 자료형, ... ) 리턴타입{
    // 함수의 이름
}
```  

### 5) Named Return  
return에서 리턴하지 않고 리턴할 데이터의 이름을 리턴 타입 앞에 작성해서 리턴하는 방식  

### 6) Recursion(Recurive call - 재귀 호출)  
* 함수가 내부에서 자기 자신을 다시 호출  
* 복잡한 문제를 단순화 시킬 수 있는 경우가 많음
* 실행속도가 느리고 메모리를 많이 사용 : 함수의 수행이 종료되기 전에 다른 함수를 호출하기 때문에 이전 함수의 메모리 공간이 해제되지 않은 상태에서 새로운 메모리를 할당받아야하기 때문  
* 합계, 팩토리얼, 피보나치 수열(금융 분야의 코딩테스트를 보실 분은 외우세요), 하노이의 탑, quick sort등이 재귀호출로 해결할 수 있는 대표적인 알고리즘들입니다.  

### 7) 함수는 일급 객체 - 함수형 프로그래밍의 핵심  
* 함수는 일급 객체라는 표현은 함수도 하나의 자료형이라는 의미입니다.  
* 함수도 변수에 대입이 가능, 함수안에 함수를 만들 수 있음  
* 함수를 리턴할 수 있음  
* 익명함수를 만드는 것이 가능 - 함수의 이름을 사용하지 않고 함수를 생성  
    자바스크립트에서는 이 방식을 권장(호이스팅 때문에)  

### 8) if문 표현식 안에서 함수 호출  


### 9) closure
* 함수 내부에서 만든 함수를 리턴하도록 해서 함수 외부에서 함수 내부의 데이터를 변경하는 것  
* 일반적인 언어에서 closure는 이 역할인데 swift에서는 람다를 클로저라 한다.  
    클로저라는 프로그래밍 언어도 있다.  
* 함수안에서 만든 변수는 지역변수로 함수 안에서 사용 가능하지만 함수 내부에서 함수를 만들면 이 함수에서는 사용이 가능하고 이 함수를 리턴하면 외부에서 리턴된 함수를 이용해서 함수 내부의 데이터를 제어할 수 있습니다.  
* 여러 곳에서 어떤 데이터를 수정해가면서 사용하고자 하는 경우 C++이나 go에서는 전역 변수를 만들거나 포인터 변수를 만들어야 합니다.  
    전역변수를 사용하게 되면 모든 곳에서 접근이 가능하기 때문에 예기치 않은 수정이 발생할 수 있습니다. 그래서 전역변수 사용을 객체 지향에서는 권장하지 않습니다.  
    
    포인터를 이용해서 다른 함수의 지역변수를 핸들링할 수 있는데 객체 지향에서는 속성을 직접 접근해서 수정하는 것을 권장하지 않습니다.  

    이런 이유들 때문에 여러 곳에서 수정가능한 데이터를 만들어서 사용하고자 할 때 closure를 이용합니다.  

### 10) 지연 호출  
* 함수를 호출할 때 앞에 defer를 추가해서 호출을 하면 이 함수가 가장 나중에 호출됩니다.  
* defer로 호출하는 함수는 stack에 저장해서 호출합니다.  
* 자원의 사용을 정리하는 코드나 예외를 처리하는 코드를 호출해야할 때 주로 이용합니다.  

### +) go 명명 규칙   
go에서는 패키지 이름과 파일 이름 및 변수 이름은 소문자로 시작하는 경우가 많음  
함수 이름은 대분자로 시작하는 경우가 많음  
go에서는 함수이름이 대문자로 시작하지 않으면 다른 패키지에서는 사용할 수 없습니다.  

## 2. Go 자료구조  
### 1) Array(배열)  
* 동일한 자료형의 데이터들의 집합  
* 크기가 고정  
* Value Type  

* 생성  
```go
var 배열이름[개수] 자료형
```  

* 값 대입
```go
배열이름 = [데이터개수]자료형{데이터 나열}
```  

* 선언과 동시에 초기화 가능  
```go
변수명:= [크기]자료형{데이터나열}
```  

* 배열의 데이터 개수는 len 함수를 이용해서 구할 수 있습니다.  

* 배열의 각 데이터를 1개씩 접근하고자 할 때는 배열 이름[인덱스]형태로 사용하면 되는데, 인덱스는 0부터 데이터 개수 -1까지 입니다.  

* +) 실행방식  
    개발자 코드 <-> 변수테이블(함수 이름) <-> stack(임시변수와 데이터) <-> Heap(반영구적인 데이터 - 함수나  구조체, 인터페이스 등)  

    함수는 호출하면 하나의 스택을 만들어서 작업을 수행하고 작업이 끝나면 호출한 곳으로 리턴합니다.  

* 배열의 데이터 일부분 접근 
```go 
배열이름[시작위치:종료위치+1]
```  
    시작위치를 생략하면 0으로 설정, 종료위치를 생략하면 len으로 구한 값  

* 배열의 전체 데이터 순회
```go
for idx, value := range 배열이름{
    // 순회하면서 수행할 내용
}
```  
    인덱스는 0부터 데이터 개수 - 1까지의 인덱스가 순서대로 대입  
    값에는 배열의 데이터들이 순차적으로 하나씩 대입됩니다.   
    인덱스나 값을 사용하지 않을 때는 변수 이름 대신에 _를 해주면 됩니다.  

* 배열의 복제  
    value타입은 다른 변수에 대입하면 복제해서 대입합니다.  
    배열은 value타입이기 때문에 배열을 다른 배열 변수에 대입하면 배열은 복제됩니다.  

* +) 자료형
    value type : 변수가 데이터 자체를 가리키는 것
    reference type : 변수가 데이터가 위치한 곳의 참조를 가리키는 것  
    ```go
    var a int = 20 // 일반적인 자료형은 value type
    fmt.Println(a) // a가 가리키는 데이터를 출력 - 20

    var ptr *int = &a
    fmt.Println(ptr) // ptr이 가리키는 데이터를 출력 - a의 주소값(시스템마다 다른 값 나옴)
    // ptr -> a가 저장된 곳의 참조 -> 20
    ```  

    자바나 자바스크립트는 모든 데이터가 Refereence Type  
    기본형(boolean, byte, short, char, int, long, float, double)은 Value type처럼 사용  

    기본형이 나닌 데이터를 출력하는 구문에 대입하면 자바는 toString()메서드를 호출한 결과를 출력  
    자바에서는 기본적으로 toString메서드를 Overriding하지 않으면 자신의 클래스 이름과 해시코드를 하나의 문자열로 묶어서 toString의 결과로 리턴합니다. Arrays.toString(배열이름)  

## 2) slice  
* 동적으로 크기가 늘어나는 배열  
* 배열과는 다르게 레퍼런스 타입  
    다른 slice에게 대입하면 참조 복사가 이루어집니다.  
    다른 slice에서 데이터를 변경하면 원본의 데이터도 변경이 됩니다.  

* 선언  
```go
var slice이름 []자료형  
```  
    배열은 선언만 하면 만들어지지만 선언은 다른 참조를 기억할 수 있는 공간만 생성이 되어 nil을 저장하고 있습니다.  
    선언을 하고 나면 반드시 공간을 할당하거나 초기화를 하거나 다른 슬라이스의 참조를 받아야합니다.  

* 공간할당
```go
make([]자료형, 개수)
make([]자료형, 개수, 용량)
```  

* 데이터 접근 방법은 배열과 동일  

* 초기화해서 생성하는 것은 가능  
    [] 자료형{데이터 나열}  
    데이터를 여러 줄에 걸쳐서 작성할 때는 마지막에 ,를 붙여야 합니다.  

* 레퍼런스 타입은 대입을 하게되면 참조를 전달하게 됩니다.  

* slice 복제  
    copy함수를 이용해서 복제할 변수와 실제 복제될 데이터를 설정하면 됩니다.  

* slice에 데이터 추가  
    append함수를 이용해서 슬라이스에 추가할 데이터를 대입해주면 됩니다.  
    가변 이수 함수라서 추가할 데이터는 1개여도 되고, 다른 슬라이스여도 되고, 직접 여러 개의 데이터를 입력해도 됩니다.  

### 3) map  
* 해시 테이블이나 딕셔너리라고 부르기도 하는 자료구조로 키와 값을 쌍으로 저장하는 자료구조  
* 레퍼런스 타입  
* 생성
``go
var 맵이름 map[키자료형]값의자료형  
var m map[string]int
```  
    키 자료형은 특별한 경우가 아니면 문자열  

* 초기화  
```go
{key:value, key:value ... }
```  

* 데이터 접근  
맵이름[키이름]
    없는 키 이름 대입하면 기본값이 리턴  
    실제 리턴되는 데이터는 2개인데 첫번째 데이터는 값이고, 두번째 데이터는 값의 존재 여부  
    등호(=)를 이용해서 값을 대입하면 없는 키는 추가되고, 존재하는 키는 수정됨  

* make(map[키의 자료형]값의자료형)으로 메모리할당 가능  

## 3. Pointer  
* 메모리의 참조를 저장하기 위한 자료형  

### 1) 선언
```go
var 변수이름 *가리킬데이터의자료형
```  
nil 값을 저장

### 2) 메모리 할당  
new(자료형)
